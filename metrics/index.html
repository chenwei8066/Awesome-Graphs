<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>有效订单量指标图谱</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="https://at.alicdn.com/t/a/font_470089_8hnbbf8n4u8.css" />
    <style>
      html, body { margin: 0; padding: 0; width: 100%; height: 100%; }
      #network { width: calc(100% - 360px); height: 100%; background-color: #fafbfc; }
      .search-bar { position: absolute; top: 24px; left: 12px; z-index: 2; width: 360px; font-size: 14px; box-shadow: 0 0 8px rgba(0,0,0,0.1); border-radius: 8px; background-color: #fff; }
      #searchInput, #searchButton { font-size: 14px; }
      #search-list { position: absolute; top: 72px; left: 12px; z-index: 999; width: 360px; background-color: #fff; display: none; font-size: 14px; text-align: left; max-height: 480px; overflow-y: auto; padding: 8px 12px; border: 1px solid #eee; border-radius: 6px; }
      .alert-message { font-size: 14px; width: 360px; height: fit-content; top: 72px; left: 12px; line-height: 24px; padding: 6px 0 6px 12px; position: absolute; z-index: 1; }
      .btn-close:focus { box-shadow: none; }
      #node-detail { 
        position: fixed; 
        right: 0; 
        top: 0; 
        width: 360px; 
        height: 100vh;
        background: #fff; 
        border-left: 1px solid #e5e7eb; 
        box-shadow: -2px 0 6px rgba(0,0,0,0.04); 
        z-index: 1000; 
        display: block;
        overflow: hidden;
      }
      .detail-header { 
        padding: 16px 20px 12px; 
        border-bottom: 1px solid #f3f4f6; 
        background: #fafbfc;
      }
      .detail-title { 
        font-size: 16px; 
        font-weight: 700; 
        color: #111827; 
        margin: 0;
      }
      .detail-content { 
        padding: 16px 20px; 
        height: calc(100vh - 80px);
        overflow-y: auto;
      }
      .g6-toolbar { background: #fff; border-radius: 8px !important; bottom: 50% !important; flex-direction: column !important; gap: 4px; left: 12px !important; opacity: 1 !important; padding: 4px !important; }
      .g6-toolbar-item { display: flex !important; }
      .metric-line { font-size: 12px; color: #111; }
      .metric-line .k { color: #6b7280; margin-right: 4px; }
      .metric-line .v { font-weight: 600; }
    </style>
  </head>
  <body>
    <div class="input-group mb-3 search-bar">
      <input type="text" id="searchInput" class="form-control" placeholder="搜索指标，如 DAU、访购率、营销补贴" aria-describedby="searchButton" />
      <button id="searchButton" class="btn btn-outline-secondary" type="button">Search</button>
    </div>
    <div id="search-list"></div>
    <div id="live-alert"></div>
    <div id="node-detail">
      <div class="detail-header">
        <h3 class="detail-title" id="detail-title">指标详情</h3>
      </div>
      <div class="detail-content" id="detail-content">
        <div style="color: #9ca3af; text-align: center; padding: 40px 20px; font-size: 14px;">
          点击图谱中的节点查看详细信息
        </div>
      </div>
    </div>
    <div id="loading-status" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; z-index: 1000;">加载中...</div>
    <div id="network"></div>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/fuzzy@0.1.3/lib/fuzzy.js"></script>
    <script src="https://unpkg.com/@antv/g6@5/dist/g6.min.js"></script>
    <script type="module">
      const BG_COLOR = '#fafbfc';
      // 健康状态颜色系统
      const HEALTHY_COLOR = '#059669';    // 绿色 - 健康状态
      const WARNING_COLOR = '#f59e0b';    // 黄色 - 预警状态  
      const PROBLEM_COLOR = '#dc2626';    // 红色 - 有问题状态
      const UNKNOWN_COLOR = '#6b7280';    // 灰色 - 未知状态
      const UNI_EDGE = '#94a3b8';
      const ROLLUP_EDGE = '#6366f1';
      const INFLU_EDGE = '#0891b2';

      // 默认fallback数据（在无法从 JSON 加载时使用）
      const defaultNodes = [
        { id: '有效订单量', _type: 'metric', _domain: '核心', _level: 0, _category: 'business_target', _weight: 1.0, _status: 'healthy' },
        { id: 'DAU', _type: 'metric', _domain: '用户', _level: 1, _category: 'core_metric', _weight: 0.9, _description: '日活跃用户数', _status: 'healthy' },
        { id: '访购率', _type: 'metric', _domain: '转化', _level: 1, _category: 'core_metric', _weight: 0.9, _description: '访问用户到购买的转化率', _status: 'warning' },
        { id: '下单频次', _type: 'metric', _domain: '行为', _level: 1, _category: 'core_metric', _weight: 0.8, _description: '用户平均下单次数', _status: 'healthy' },
        { id: '笔单价', _type: 'metric', _domain: '收益', _level: 1, _category: 'core_metric', _weight: 0.8, _description: '平均订单金额', _status: 'problem' },
        { id: '闪购DAU', _type: 'metric', _domain: '闪购', _level: 2, _category: 'segment', _weight: 0.7, _status: 'healthy' },
        { id: '非闪购DAU', _type: 'metric', _domain: '非闪购', _level: 2, _category: 'segment', _weight: 0.6, _status: 'warning' },
        { id: 'ET端DAU', _type: 'metric', _domain: '闪购', _level: 3, _category: 'platform', _weight: 0.6, _status: 'healthy' },
        { id: '营销补贴', _type: 'factor', _domain: '营销', _level: 2, _category: 'conversion_factor', _weight: 0.7, _description: '影响访购率的营销因素', _status: 'problem' },
        { id: '供给丰富度', _type: 'factor', _domain: '供给', _level: 2, _category: 'conversion_factor', _weight: 0.8, _description: '商户和商品供给情况', _status: 'healthy' }
      ];
      const defaultEdges = [
        { from: 'DAU', to: '有效订单量', _type: 'rollup', _impact: 0.25 },
        { from: '访购率', to: '有效订单量', _type: 'rollup', _impact: 0.25 },
        { from: '下单频次', to: '有效订单量', _type: 'rollup', _impact: 0.25 },
        { from: '笔单价', to: '有效订单量', _type: 'rollup', _impact: 0.25 },
        { from: '闪购DAU', to: 'DAU', _type: 'rollup', _impact: 0.6 },
        { from: '非闪购DAU', to: 'DAU', _type: 'rollup', _impact: 0.4 },
        { from: 'ET端DAU', to: '闪购DAU', _type: 'rollup', _impact: 0.6 },
        { from: '营销补贴', to: '访购率', _type: 'influences', _impact: 0.4 },
        { from: '供给丰富度', to: '访购率', _type: 'influences', _impact: 0.35 }
      ];

      const idOf = G6.idOf;

      const transformData = (data) => {
        (data.edges || []).forEach((e) => { e.source = e.from; e.target = e.to; });
        return data;
      };

      const colorByHealthStatus = (node) => {
        // 检查节点的健康状态字段
        const status = node._status || node._health || 'healthy'; // 默认为健康
        
        switch (status.toLowerCase()) {
          case 'healthy':
          case 'good':
          case 'normal':
            return HEALTHY_COLOR;
          case 'warning':
          case 'caution':
          case 'attention':
            return WARNING_COLOR;
          case 'problem':
          case 'error':
          case 'critical':
          case 'bad':
            return PROBLEM_COLOR;
          case 'unknown':
          case 'undefined':
          case null:
          case undefined:
            return UNKNOWN_COLOR;
          default:
            return HEALTHY_COLOR; // 默认为健康状态
        }
      };

      const sizeBy = (nodeId, nodes, edges, minSize = 20, maxSize = 90) => {
        const node = nodes.find((n) => n.id === nodeId) || {};
        const degree = edges.filter((e) => e.source === nodeId || e.target === nodeId).length;
        const weight = Number(node._weight || 0);
        // 影响力 = 0.7*度数标准化 + 0.3*权重
        const degrees = nodes.map((n) => edges.filter((e) => e.source === n.id || e.target === n.id).length);
        const minD = Math.min(...degrees, 0);
        const maxD = Math.max(...degrees, 1);
        const normD = (degree - minD) / (maxD - minD || 1);
        const influence = 0.7 * normD + 0.3 * Math.min(weight, 1);
        return minSize + influence * (maxSize - minSize);
      };

      class OrganicLayout extends G6.BaseLayout {
        async execute(data) {
          const layoutParams = calculateLayoutParams();
          const { gap = 30, ranksep = 320, nodeSize = 40, verticalSpread = 0.15, randomOffset = 0.05 } = this.options;
          
          // 使用计算得到的布局参数
          const actualGap = layoutParams.gap || gap;
          const actualRanksep = layoutParams.ranksep || ranksep;
          const actualVerticalSpread = layoutParams.verticalSpread || verticalSpread;
          const actualRandomOffset = layoutParams.randomOffset || randomOffset;
          
          console.log(`使用布局模式: ${layoutParams.layoutMode}, 屏幕比例: ${layoutParams.aspectRatio.toFixed(2)}, ranksep: ${actualRanksep}, gap: ${actualGap}`);
          const nodes = data.nodes.map(node => ({
            id: node.id,
            style: { ...node.style },
            _level: node._level || 0,
            _weight: node._weight || 0.5,
            _category: node._category,
            size: this.options.nodeSize ? this.options.nodeSize(node) : nodeSize
          }));

          // 按层级分组
          const layersObject = {};
          nodes.forEach(node => {
            const level = node._level;
            if (!(level in layersObject)) layersObject[level] = [];
            layersObject[level].push(node);
          });

          // 处理孤立节点
          const connectedNodes = new Set();
          data.edges.forEach(edge => {
            connectedNodes.add(edge.source);
            connectedNodes.add(edge.target);
          });

          const isolatedNodes = nodes.filter(n => !connectedNodes.has(n.id));
          if (isolatedNodes.length > 0) {
            const maxLevel = Math.max(...Object.keys(layersObject).map(Number));
            const isolatedLevel = maxLevel + 1;
            layersObject[isolatedLevel] = isolatedNodes.map(node => {
              node._level = isolatedLevel;
              return node;
            });
          }

          const sortedLevels = Object.keys(layersObject).map(Number).sort((a, b) => a - b);
          
          // 为每层计算位置
          sortedLevels.forEach(level => {
            const layer = layersObject[level];
            const layerSize = layer.length;
            
            // 如果是第一层（L0），按重要性排序
            if (level === 0) {
              layer.sort((a, b) => {
                const degreeA = data.edges.filter(e => e.source === a.id || e.target === a.id).length;
                const degreeB = data.edges.filter(e => e.source === b.id || e.target === b.id).length;
                const importanceA = (a._weight || 0) * 0.3 + degreeA * 0.7;
                const importanceB = (b._weight || 0) * 0.3 + degreeB * 0.7;
                return importanceB - importanceA;
              });
            } else {
              // 对于其他层级，根据与前一层的连接关系进行分组排序
              const prevLevel = level - 1;
              const prevLayer = layersObject[prevLevel] || [];
              
              // 创建连接组
              const connectionGroups = [];
              const unconnectedNodes = [];
              
              // 为前一层的每个节点创建对应的连接组
              prevLayer.forEach((prevNode, prevIndex) => {
                const connectedNodes = [];
                
                // 找到连接到这个前一层节点的当前层节点
                data.edges.forEach(edge => {
                  if (edge.source === prevNode.id) {
                    const targetNode = layer.find(n => n.id === edge.target);
                    if (targetNode) connectedNodes.push(targetNode);
                  }
                  if (edge.target === prevNode.id) {
                    const sourceNode = layer.find(n => n.id === edge.source);
                    if (sourceNode) connectedNodes.push(sourceNode);
                  }
                });
                
                if (connectedNodes.length > 0) {
                  // 按重要性对组内节点排序
                  connectedNodes.sort((a, b) => {
                    const degreeA = data.edges.filter(e => e.source === a.id || e.target === a.id).length;
                    const degreeB = data.edges.filter(e => e.source === b.id || e.target === b.id).length;
                    const importanceA = (a._weight || 0) * 0.3 + degreeA * 0.7;
                    const importanceB = (b._weight || 0) * 0.3 + degreeB * 0.7;
                    return importanceB - importanceA;
                  });
                  
                  connectionGroups.push({
                    prevNode: prevNode,
                    prevIndex: prevIndex,
                    nodes: connectedNodes,
                    targetY: prevNode.style.y || 0
                  });
                }
              });
              
              // 找出未连接的节点
              const connectedNodeIds = new Set();
              connectionGroups.forEach(group => {
                group.nodes.forEach(node => connectedNodeIds.add(node.id));
              });
              
              layer.forEach(node => {
                if (!connectedNodeIds.has(node.id)) {
                  unconnectedNodes.push(node);
                }
              });
              
              // 按前一层节点的Y位置排序连接组
              connectionGroups.sort((a, b) => a.targetY - b.targetY);
              
              // 重新组装layer数组，保持连接关系的垂直对应
              const sortedLayer = [];
              connectionGroups.forEach(group => {
                sortedLayer.push(...group.nodes);
              });
              
              // 将未连接的节点按重要性排序后添加到末尾
              unconnectedNodes.sort((a, b) => {
                const degreeA = data.edges.filter(e => e.source === a.id || e.target === a.id).length;
                const degreeB = data.edges.filter(e => e.source === b.id || e.target === b.id).length;
                const importanceA = (a._weight || 0) * 0.3 + degreeA * 0.7;
                const importanceB = (b._weight || 0) * 0.3 + degreeB * 0.7;
                return importanceB - importanceA;
              });
              sortedLayer.push(...unconnectedNodes);
              
              // 更新layer为排序后的数组
              layersObject[level] = sortedLayer;
              layer.length = 0;
              layer.push(...sortedLayer);
            }

            // 计算X坐标（层级位置）
            const baseX = level * actualRanksep;
            
            // 计算节点间的最小间距（考虑节点大小）
            const getMinSpacing = (nodeA, nodeB) => {
              const sizeA = nodeA.size || nodeSize;
              const sizeB = nodeB.size || nodeSize;
              return (sizeA + sizeB) / 2 + actualGap;
            };
            
            // 计算Y坐标（垂直分布）
            if (layerSize === 1) {
              layer[0].style.x = baseX + (Math.random() - 0.5) * actualRandomOffset * actualRanksep * 0.3;
              layer[0].style.y = (Math.random() - 0.5) * actualRandomOffset * actualGap * 0.3;
            } else {
              // 计算总需要的高度
              let totalHeight = 0;
              for (let i = 0; i < layerSize - 1; i++) {
                totalHeight += getMinSpacing(layer[i], layer[i + 1]);
              }
              
              // 分配Y坐标
              let currentY = -totalHeight / 2;
              layer.forEach((node, index) => {
                if (index === 0) {
                  node.style.y = currentY;
                } else {
                  currentY += getMinSpacing(layer[index - 1], node);
                  node.style.y = currentY;
                }
                
                // 添加垂直交错（减少幅度）
                const stagger = (index % 2 === 0 ? 1 : -1) * actualVerticalSpread * actualGap * 0.2;
                
                // 添加微量随机偏移
                const randomY = (Math.random() - 0.5) * actualRandomOffset * actualGap * 0.5;
                const randomX = (Math.random() - 0.5) * actualRandomOffset * actualRanksep * 0.2;
                
                // 重要节点位置微调（更靠近中心）
                const importance = (node._weight || 0) + 
                  data.edges.filter(e => e.source === node.id || e.target === node.id).length * 0.1;
                const importanceY = -importance * actualGap * 0.1;
                
                node.style.x = baseX + randomX;
                node.style.y = node.style.y + stagger + randomY + importanceY;
              });
            }
          });

          // 碰撞检测和调整
          this.resolveCollisions(nodes, actualGap * 0.6);

          return { nodes };
        }

        // 碰撞检测和解决方法
        resolveCollisions(nodes, minDistance) {
          const maxIterations = 10;
          let iteration = 0;
          
          while (iteration < maxIterations) {
            let hasCollision = false;
            
            for (let i = 0; i < nodes.length; i++) {
              for (let j = i + 1; j < nodes.length; j++) {
                const nodeA = nodes[i];
                const nodeB = nodes[j];
                
                // 只检查相邻层级的节点
                if (Math.abs(nodeA._level - nodeB._level) > 1) continue;
                
                const dx = nodeA.style.x - nodeB.style.x;
                const dy = nodeA.style.y - nodeB.style.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const sizeA = nodeA.size || 40;
                const sizeB = nodeB.size || 40;
                const requiredDistance = (sizeA + sizeB) / 2 + minDistance;
                
                if (distance < requiredDistance && distance > 0) {
                  hasCollision = true;
                  
                  // 计算调整向量
                  const overlap = requiredDistance - distance;
                  const adjustX = (dx / distance) * overlap * 0.5;
                  const adjustY = (dy / distance) * overlap * 0.5;
                  
                  // 同层级的节点主要在Y方向调整，不同层级的在X方向也调整
                  if (nodeA._level === nodeB._level) {
                    nodeA.style.y += adjustY;
                    nodeB.style.y -= adjustY;
                  } else {
                    nodeA.style.x += adjustX * 0.3;
                    nodeA.style.y += adjustY;
                    nodeB.style.x -= adjustX * 0.3;
                    nodeB.style.y -= adjustY;
                  }
                }
              }
            }
            
            if (!hasCollision) break;
            iteration++;
          }
        }
      }

      class ClickElement extends G6.BaseBehavior {
        constructor(context, options) { super(context, options); this.bindEvents(); }
        async clearState() { const { graph } = this.context; const { nodes, edges } = graph.getData(); const s = {}; [...nodes, ...edges].forEach(d => s[idOf(d)] = []); await graph.setElementState(s, false); }
        onNodeClick = async (event) => {
          await this.clearState();
          toggleListVisibility(false);
          const { direction = 'out', onlyNeighbors } = event;
          const nodeId = event.target.id; const { graph } = this.context; const { nodes, edges } = graph.getData();
          let relatedIds;
          if (onlyNeighbors) {
            const neighborNodes = graph.getNeighborNodesData(nodeId);
            const neighborEdges = graph.getRelatedEdgesData(nodeId);
            const oneLevelIds = [...neighborNodes, ...neighborEdges].map(idOf);
            relatedIds = [...oneLevelIds, nodeId];
            graph.updateNodeData(prev => prev.filter(n => relatedIds.includes(n.id) && (n.style.level = oneLevelIds.includes(n.id) ? 1 : 0)));
            const states = {}; [...nodes, ...edges].forEach(d => states[idOf(d)] = relatedIds.includes(idOf(d)) ? ['link'] : ['inactive']);
            await graph.setElementState(states);
          } else {
            const levels = getLevelMap(nodeId, direction);
            relatedIds = Object.keys(levels);
            graph.updateNodeData(prev => prev.filter(n => relatedIds.includes(n.id) && (n.style.level = levels[n.id])));
            graph.updateEdgeData(prev => prev.filter(e => (levels[e.source] || levels[e.target]) && (e.style.level = Math.min(levels[e.source], levels[e.target]))));
            const states = {}; nodes.forEach(n => states[n.id] = relatedIds.includes(n.id) ? ['link'] : ['inactive']);
            edges.forEach(e => states[idOf(e)] = relatedIds.includes(e.source) && relatedIds.includes(e.target) ? ['link'] : ['inactive']);
            await graph.setElementState(states);
          }
        };
        onCanvasClick = async () => { await this.clearState(); toggleListVisibility(false); clearSearchInput(); };
        bindEvents() { const { graph } = this.context; graph.on('node:click', this.onNodeClick); graph.on('canvas:click', this.onCanvasClick); }
        unbindEvents() { const { graph } = this.context; graph.off('node:click', this.onNodeClick); graph.off('canvas:click', this.onCanvasClick); }
        destroy() { this.unbindEvents(); super.destroy(); }
      }

      const getLevelMap = (nodeId, direction) => {
        const stack = [nodeId]; const visited = new Set(); const levelMap = { [nodeId]: 0 };
        const processEdge = (source, target, parentLevel) => { if (!visited.has(target)) { const nl = parentLevel + 1; if (!levelMap[target] || nl < levelMap[target]) { levelMap[target] = nl; stack.push(target); } } };
        while (stack.length) { const id = stack.pop(); if (!visited.has(id)) { visited.add(id); const pl = levelMap[id]; const related = graph.getRelatedEdgesData(id); related.forEach(edge => {
          if (direction === 'out') { if (edge.source === id) processEdge(edge.source, edge.target, pl); else if (edge._bidirectional) processEdge(edge.target, edge.source, pl); }
          else if (direction === 'in') { if (edge.target === id) processEdge(edge.target, edge.source, pl); else if (edge._bidirectional) processEdge(edge.source, edge.target, pl); }
        }); } }
        return levelMap;
      };

      const toggleListVisibility = (isShow) => { document.getElementById('search-list').style.display = isShow ? 'block' : 'none'; };
      const clearSearchInput = () => { document.getElementById('searchInput').value = ''; };
      const removeElement = (el) => { while (el.firstChild) el.removeChild(el.firstChild); };

      class SearchBar extends G6.BasePlugin {
        liveAlert = document.getElementById('live-alert');
        searchInput = document.getElementById('searchInput');
        searchButton = document.getElementById('searchButton');
        target;
        constructor(context, options) { super(context, options); this.bindEvents(); }
        appendAlert = (message, type) => { removeElement(this.liveAlert); const w = document.createElement('div'); w.innerHTML = [`<div class="alert alert-${type} alert-dismissible alert-message" role="alert">`, `   <div>${message}</div>`, '   <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>', '</div>'].join(''); this.liveAlert.append(w); };
        handleInputKeyup = (event) => {
          const { graph } = this.context; removeElement(this.liveAlert);
          const PRE = '<b style="color: #1783FF;">'; const POST = '</b>';
          const data = graph.getData(); const nodeList = data.nodes.map(n => ({ id: n.id }));
          const filtered = fuzzy.filter(this.searchInput.value, nodeList, { pre: PRE, post: POST, extract: el => el.id });
          const sorted = filtered.sort((a, b) => { const regx = new RegExp(PRE, 'g'); const ac = (a.string.match(regx) || []).length; const bc = (b.string.match(regx) || []).length; if (ac !== bc) return bc - ac; const regx2 = new RegExp(POST + PRE, 'g'); const as = (a.string.match(regx2) || []).length; const bs = (b.string.match(regx2) || []).length; if (as !== bs) return bs - as; return a.string.indexOf(PRE) - b.string.indexOf(PRE); });
          document.getElementById('search-list').innerHTML = sorted.map(el => `<div class="mb-1">${el.string}</div>`).join('');
          this.target = sorted[0]?.original.id || '';
          toggleListVisibility(true);
          if (event.keyCode === 13) { event.preventDefault(); this.searchButton.click(); }
          else if (this.searchInput.value === '') { graph.emit('canvas:click', { targetType: 'canvas' }); }
        };
        handleButtonClick = async () => { const { graph } = this.context; const v = this.searchInput.value; if (!v) return; if (!this.target) { this.appendAlert(`未找到 “${v}”`, 'warning'); graph.emit('canvas:click', { targetType: 'canvas' }); }
          graph.emit('node:click', { target: graph.getNodeData(this.target), targetType: 'node', direction: 'out' }); await graph.fitView(); };
        bindEvents() { this.searchInput.addEventListener('keyup', this.handleInputKeyup); this.searchButton.addEventListener('click', this.handleButtonClick); }
        unbindEvents() { this.searchInput.removeEventListener('keyup', this.handleInputKeyup); this.searchButton.removeEventListener('click', this.handleButtonClick); }
        destroy() { this.unbindEvents(); super.destroy(); }
      }

      class DetailContent extends G6.BasePlugin {
        detailTitle = document.getElementById('detail-title');
        detailContent = document.getElementById('detail-content');
        
        constructor(context, options) { 
          super(context, options); 
          this.bindEvents(); 
        }
        
        updateContent = (node) => {
          if (!node) return;
          
          // 设置标题
          this.detailTitle.textContent = node.id;
          
          // 清空内容区域
          removeElement(this.detailContent);
          
          const line = (k, v, color) => { 
            const div = document.createElement('div'); 
            div.className = 'metric-line'; 
            div.style.marginBottom = '12px';
            div.style.paddingBottom = '8px';
            div.style.borderBottom = '1px solid #f3f4f6';
            const valueSpan = color ? `<span style="color: ${color}; font-weight: 600; font-size: 14px;">${v}</span>` : `<span style="font-weight: 600; font-size: 14px; color: #111827;">${v}</span>`;
            div.innerHTML = `<div style="color: #6b7280; font-size: 12px; margin-bottom: 4px;">${k}</div>${valueSpan}`; 
            return div; 
          };
          
          // 显示健康状态
          if (node._status || node._health) {
            const status = node._status || node._health;
            const statusText = status === 'healthy' ? '健康' : 
                              status === 'warning' ? '预警' : 
                              status === 'problem' ? '异常' : '未知';
            const statusColor = colorByHealthStatus(node);
            this.detailContent.appendChild(line('健康状态', statusText, statusColor));
          }
          
          if (node._description) this.detailContent.appendChild(line('指标说明', node._description));
          if (node._domain) this.detailContent.appendChild(line('业务域', node._domain));
          if (node._category) this.detailContent.appendChild(line('指标类型', node._category));
          if (node._level != null) this.detailContent.appendChild(line('层级', `L${node._level}`));
          if (node._weight != null) this.detailContent.appendChild(line('权重', node._weight));
        };
        
        onNodeClick = (event) => { 
          const { target } = event; 
          const { graph } = this.context; 
          const data = graph.getNodeData(target.id); 
          this.updateContent(data); 
        };
        
        bindEvents() { 
          const { graph } = this.context; 
          graph.on('node:click', this.onNodeClick); 
        }
        
        unbindEvents() { 
          const { graph } = this.context; 
          graph.off('node:click', this.onNodeClick); 
        }
        
        destroy() { 
          this.unbindEvents(); 
          super.destroy(); 
        }
      }

      G6.register('behavior', 'click-element', ClickElement);
      G6.register('layout', 'organic', OrganicLayout);

      const toolbarOption = { type: 'toolbar', position: 'bottom-left', onClick: (item) => { if (item === 'zoom-in') graph.zoomBy(1.2); if (item === 'zoom-out') graph.zoomBy(0.8); if (item === 'auto-fit') graph.fitView(); }, getItems: () => ([{ id: 'zoom-in', value: 'zoom-in' }, { id: 'zoom-out', value: 'zoom-out' }, { id: 'auto-fit', value: 'auto-fit' }]) };

      const contextmenuOption = { type: 'contextmenu', trigger: 'contextmenu', onClick: (v, element, target) => { if (v === 'reference-network') graph.emit('node:click', { target, targetType: 'node', direction: 'out' }); if (v === 'citation-network') graph.emit('node:click', { target, targetType: 'node', direction: 'in' }); if (v === 'direct-neighbors') graph.emit('node:click', { target, targetType: 'node', onlyNeighbors: true }); graph.fitView(); }, getItems: () => ([{ name: '下游影响网络', value: 'reference-network' }, { name: '上游依赖网络', value: 'citation-network' }, { name: '直接邻居', value: 'direct-neighbors' }]), enable: (e) => e.targetType === 'node' };

      const colorOfEdge = (e) => {
        if (e._type === 'rollup') return '#6366f1'; // 紫色，表示聚合关系
        if (e._type === 'influences') return '#0891b2'; // 蓝色，表示影响关系
        if (e._type === 'depends') return '#dc2626'; // 红色，表示依赖关系
        return '#94a3b8'; // 默认灰色
      };
      const lineDashOf = (e) => {
        if (e._type === 'influences') return [6, 6]; // 影响关系用虚线
        if (e._type === 'depends') return [3, 3]; // 依赖关系用短虚线
        return undefined; // rollup用实线
      };

      // 先注册插件
      G6.register('plugin', 'search-bar', SearchBar);
      G6.register('plugin', 'detail-content', DetailContent);

      // 提升为全局，便于行为/函数访问
      let graph;

      // 计算适应屏幕比例的图谱形状和布局参数
      const calculateLayoutParams = () => {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const graphWidth = windowWidth - 360; // 减去右侧面板宽度
        const aspectRatio = graphWidth / windowHeight; // 基于实际图谱区域计算比例
        
        // 图谱可用空间计算 - 已经在CSS中为右侧面板预留了360px  
        const uiReservedWidth = aspectRatio > 1.8 ? 100 : aspectRatio > 1.4 ? 150 : 200; // 搜索框等UI元素
        const uiReservedHeight = 120; // 减少顶部底部保留空间
        const availableWidth = graphWidth - uiReservedWidth;
        const availableHeight = windowHeight - uiReservedHeight;
        
        // 计算图谱层级数量和节点分布
        const nodes = graphData?.nodes || [];
        const maxLevel = Math.max(...nodes.map(n => n._level || 0), 6);
        const levelCounts = {};
        nodes.forEach(n => {
          const level = n._level || 0;
          levelCounts[level] = (levelCounts[level] || 0) + 1;
        });
        const maxNodesInLevel = Math.max(...Object.values(levelCounts), 1);
        
        // 根据屏幕比例决定布局策略
        let ranksep, gap, layoutMode;
        
        if (aspectRatio > 2.0) {
          // 超宽屏：极度拉伸水平，压缩垂直
          layoutMode = 'ultra-wide';
          ranksep = Math.max(400, availableWidth * 0.85 / (maxLevel + 1));
          gap = Math.max(18, availableHeight / (maxNodesInLevel + 3));
        } else if (aspectRatio > 1.6) {
          // 宽屏：标准16:9或21:9
          layoutMode = 'wide';
          ranksep = Math.max(320, availableWidth * 0.8 / (maxLevel + 1));
          gap = Math.max(22, availableHeight / (maxNodesInLevel + 2));
        } else if (aspectRatio > 1.2) {
          // 标准屏：4:3到16:10
          layoutMode = 'standard';
          ranksep = Math.max(280, availableWidth * 0.75 / (maxLevel + 1));
          gap = Math.max(28, availableHeight / (maxNodesInLevel + 1));
        } else {
          // 竖屏或正方形：调整为更紧凑的布局
          layoutMode = 'compact';
          ranksep = Math.max(220, availableWidth * 0.7 / (maxLevel + 1));
          gap = Math.max(32, availableHeight / (maxNodesInLevel + 1));
        }
        
        // 确保间距在合理范围内，但允许更大的ranksep
        ranksep = Math.max(200, Math.min(800, ranksep));
        gap = Math.max(18, Math.min(60, gap));
        
        // 动态计算padding，宽屏减少水平padding以充分利用空间
        const horizontalPadding = aspectRatio > 2.0 ? Math.max(30, windowWidth * 0.02) :
                                  aspectRatio > 1.6 ? Math.max(40, windowWidth * 0.03) :
                                  aspectRatio > 1.2 ? Math.max(50, windowWidth * 0.04) :
                                  Math.max(60, windowWidth * 0.05);
        const verticalPadding = Math.max(15, windowHeight * 0.025);
        
        // 计算其他UI参数
        const fontSize = Math.max(8, Math.min(14, Math.sqrt(windowWidth * windowHeight) / 120));
        const labelMaxWidth = aspectRatio > 2.0 ? '300%' : 
                              aspectRatio > 1.6 ? '250%' : 
                              aspectRatio > 1.2 ? '200%' : '180%';
        
        return {
          ranksep,
          gap,
          layoutMode,
          aspectRatio,
          availableWidth,
          availableHeight,
          maxLevel,
          maxNodesInLevel,
          padding: [verticalPadding, horizontalPadding, verticalPadding, horizontalPadding],
          fontSize,
          labelMaxWidth,
          // 布局微调参数
          verticalSpread: aspectRatio > 1.8 ? 0.1 : aspectRatio > 1.4 ? 0.15 : 0.2,
          randomOffset: aspectRatio > 1.8 ? 0.03 : aspectRatio > 1.4 ? 0.05 : 0.08
        };
      };

      let graphData = null; // 全局存储数据用于重新计算

      const buildGraph = async (data) => {
        console.log('构建图谱，输入数据:', data);
        graphData = data; // 存储数据
        const transformedData = transformData(data);
        console.log('转换后数据:', transformedData);
        
        const layoutParams = calculateLayoutParams();
        console.log('计算的布局参数:', layoutParams);
        
        graph = new G6.Graph({
          container: 'network',
          data: transformedData,
          animation: false,
          autoFit: 'view',
          padding: layoutParams.padding,
          background: BG_COLOR,
          node: {
            style: {
              size: (d) => sizeBy(d.id, data.nodes, data.edges),
              fill: (d) => colorByHealthStatus(d),
              iconFontFamily: 'iconfont',
              iconText: (d) => {
                if (d._category === 'business_target') return '\uE65F'; // 目标
                if (d._category === 'core_metric') return '\uE7B0'; // 指标
                if (d._category === 'segment' || d._category === 'platform') return '\uE6AB'; // 平台
                if (d._category === 'user_group' || d._category === 'user_type') return '\uE65D'; // 用户
                if (d._category === 'conversion_factor' || d._type === 'factor') return '\uE6CA'; // 因子
                if (d._category === 'marketing_tool' || d._type === 'tool') return '\uE6BB'; // 工具
                return '\uE7B0';
              },
              label: true,
              labelText: (d) => d._description ? `${d.id}\n${d._description}` : d.id,
              labelFontSize: layoutParams.fontSize,
              labelBackground: true,
              labelBackgroundFill: '#e5e7eb',
              labelPadding: [0, 6],
              labelBackgroundRadius: 4,
              labelMaxWidth: layoutParams.labelMaxWidth,
              labelWordWrap: true
            },
            state: {
              inactive: { fill: '#cbd5e1', iconOpacity: 0.6, labelBackground: false },
              link: { labelFontWeight: 'bold', halo: (d) => d.style.level === 0 }
            }
          },
          edge: {
            style: {
              stroke: (e) => colorOfEdge(e),
              lineDash: (e) => lineDashOf(e),
              endArrow: true,
              lineWidth: (e) => 1 + 2 * Number(e._impact || 0),
              type: (e) => {
                // 根据关系类型选择不同的连线样式
                if (e._type === 'influences') return 'quadratic'; // 影响关系用曲线
                if (e._type === 'depends') return 'cubic'; // 依赖关系用贝塞尔曲线
                return 'polyline'; // rollup用折线（更有机）
              },
              controlPoints: (e) => {
                // 为不同类型的边添加控制点，增加有机感
                if (e._type === 'influences') {
                  return [{ x: 0.3, y: 0.2 }, { x: 0.7, y: -0.2 }]; // 轻微波浪
                }
                if (e._type === 'depends') {
                  return [{ x: 0.25, y: -0.3 }, { x: 0.75, y: 0.3 }]; // S形曲线
                }
                return undefined; // rollup保持直线或轻微弯曲
              },
              opacity: 0.8,
              strokeOpacity: 0.8
            },
            state: {
              inactive: { opacity: 0.15, strokeOpacity: 0.15 },
              link: { 
                lineWidth: (e) => 1.5 + 2 * Number(e._impact || 0), 
                halo: false,
                opacity: 1,
                strokeOpacity: 1
              }
            }
          },
          layout: [
            { type: 'antv-dagre', rankdir: 'LR', ranksep: layoutParams.ranksep, nodesep: Math.max(10, layoutParams.gap * 0.4), controlPoints: true, nodeSize: (d) => sizeBy(d.id, transformedData.nodes, transformedData.edges) + 20 },
            { type: 'organic', gap: layoutParams.gap, ranksep: layoutParams.ranksep, verticalSpread: layoutParams.verticalSpread, randomOffset: layoutParams.randomOffset, nodeSize: (d) => sizeBy(d.id, transformedData.nodes, transformedData.edges) }
          ],
          behaviors: ['drag-element', 'drag-canvas', 'zoom-canvas', 'click-element'],
          plugins: [toolbarOption, contextmenuOption, 'search-bar', 'detail-content']
        });

        await document.fonts.ready;
        await graph.render();
        setTimeout(() => {
          graph.render();
          document.getElementById('loading-status').style.display = 'none';
        }, 16);
        return graph;
      };

      const fetchJsonSafe = async (path) => {
        try {
          const res = await fetch(path, { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          return await res.json();
        } catch (e) { return null; }
      };

      let lastKnownModified = null;
      let refreshInterval = null;

      const loadAndRenderGraph = async () => {
        // 优先尝试从Markdown解析API加载数据
        let loadedGraphData = await fetchJsonSafe('http://localhost:3001/api/graph-data');
        
        // 如果API不可用，尝试静态JSON文件
        if (!loadedGraphData) {
          console.log('Markdown API不可用，尝试静态JSON文件');
          const loadedNodes = await fetchJsonSafe('./data/nodes.json');
          const loadedEdges = await fetchJsonSafe('./data/edges.json');
          loadedGraphData = {
            nodes: loadedNodes || defaultNodes,
            edges: loadedEdges || defaultEdges
          };
        } else {
          console.log('成功从Markdown解析API加载数据');
          console.log('节点数:', loadedGraphData.nodes?.length, '边数:', loadedGraphData.edges?.length);
        }

        // 如果已有图实例，销毁后重建
        if (graph) {
          graph.destroy();
        }
        await buildGraph(loadedGraphData);
      };

      const checkForUpdates = async () => {
        try {
          const status = await fetchJsonSafe('http://localhost:3001/api/status');
          if (status && status.lastModified && status.lastModified !== lastKnownModified) {
            console.log('检测到datas.md文件变化，重新加载图谱');
            lastKnownModified = status.lastModified;
            await loadAndRenderGraph();
          }
        } catch (error) {
          console.log('无法检查文件状态，API可能不可用');
        }
      };

      // 防抖函数，避免窗口大小调整时频繁重新布局
      const debounce = (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      };

      // 窗口大小变化时重新布局
      const handleResize = debounce(async () => {
        if (graph && graphData) {
          console.log('窗口大小变化，重新计算布局');
          const newParams = calculateLayoutParams();
          console.log('新的布局参数:', newParams);
          
          // 销毁当前图谱并重新构建
          graph.destroy();
          await buildGraph(graphData);
        }
      }, 300);

      const main = async () => {
        await loadAndRenderGraph();
        
        // 添加窗口大小变化监听
        window.addEventListener('resize', handleResize);
        
        // 启动定期检查文件变化
        refreshInterval = setInterval(checkForUpdates, 2000);
        
        // 获取初始文件状态
        try {
          const status = await fetchJsonSafe('http://localhost:3001/api/status');
          if (status && status.lastModified) {
            lastKnownModified = status.lastModified;
          }
        } catch (error) {
          console.log('无法获取初始文件状态');
        }
      };

      main();
    </script>
  </body>
</html>


