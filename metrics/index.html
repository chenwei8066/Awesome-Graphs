<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>有效订单量指标图谱</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="https://at.alicdn.com/t/a/font_470089_8hnbbf8n4u8.css" />
    <style>
      html, body { margin: 0; padding: 0; width: 100%; height: 100%; }
      #network { width: 100%; height: 100%; }
      .search-bar { position: absolute; top: 24px; left: 12px; z-index: 2; width: 360px; font-size: 14px; box-shadow: 0 0 8px rgba(0,0,0,0.1); border-radius: 8px; background-color: #fff; }
      #searchInput, #searchButton { font-size: 14px; }
      #search-list { position: absolute; top: 72px; left: 12px; z-index: 999; width: 360px; background-color: #fff; display: none; font-size: 14px; text-align: left; max-height: 480px; overflow-y: auto; padding: 8px 12px; border: 1px solid #eee; border-radius: 6px; }
      .alert-message { font-size: 14px; width: 360px; height: fit-content; top: 72px; left: 12px; line-height: 24px; padding: 6px 0 6px 12px; position: absolute; z-index: 1; }
      .btn-close:focus { box-shadow: none; }
      #node-detail { left: 50%; width: max-content; top: 20px; transform: translateX(-50%); position: absolute; border: 0; border-radius: 8px; background-color: rgba(255,255,255,0.9); padding: 10px 12px; z-index: 1000; text-align: left; box-shadow: 0 2px 12px rgba(0,0,0,0.12); }
      .g6-toolbar { background: #fff; border-radius: 8px !important; bottom: 50% !important; flex-direction: column !important; gap: 4px; left: 12px !important; opacity: 1 !important; padding: 4px !important; }
      .g6-toolbar-item { display: flex !important; }
      .metric-line { font-size: 12px; color: #111; }
      .metric-line .k { color: #6b7280; margin-right: 4px; }
      .metric-line .v { font-weight: 600; }
      .legend { position: absolute; right: 12px; top: 12px; z-index: 2; background: #fff; border: 1px solid #eee; border-radius: 8px; padding: 8px 10px; font-size: 12px; }
      .legend .item { display: flex; align-items: center; gap: 6px; margin: 4px 0; }
      .legend .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    </style>
  </head>
  <body>
    <div class="input-group mb-3 search-bar">
      <input type="text" id="searchInput" class="form-control" placeholder="搜索指标，如 DAU、访购率、营销补贴" aria-describedby="searchButton" />
      <button id="searchButton" class="btn btn-outline-secondary" type="button">Search</button>
    </div>
    <div id="search-list"></div>
    <div id="live-alert"></div>
    <div id="node-detail"></div>
    <div id="loading-status" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; z-index: 1000;">加载中...</div>
    <div id="network"></div>

    <div class="legend">
      <div class="item"><span class="dot" style="background:#1e40af"></span><span>核心指标</span></div>
      <div class="item"><span class="dot" style="background:#059669"></span><span>业务线</span></div>
      <div class="item"><span class="dot" style="background:#dc2626"></span><span>平台/用户群</span></div>
      <div class="item"><span class="dot" style="background:#7c3aed"></span><span>影响因子</span></div>
      <div class="item"><span class="dot" style="background:#ea580c"></span><span>营销工具</span></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/fuzzy@0.1.3/lib/fuzzy.js"></script>
    <script src="https://unpkg.com/@antv/g6@5/dist/g6.min.js"></script>
    <script type="module">
      const BG_COLOR = '#FFF';
      const CORE_TARGET = '#1e40af';     // 核心目标
      const CORE_METRIC = '#059669';     // 核心指标
      const SEGMENT = '#dc2626';         // 业务线/平台
      const FACTOR = '#7c3aed';          // 影响因子
      const TOOL = '#ea580c';            // 工具
      const UNI_EDGE = '#94a3b8';
      const ROLLUP_EDGE = '#6366f1';
      const INFLU_EDGE = '#0891b2';

      // 默认fallback数据（在无法从 JSON 加载时使用）
      const defaultNodes = [
        { id: '有效订单量', _type: 'metric', _domain: '核心', _level: 0, _category: 'business_target', _weight: 1.0 },
        { id: 'DAU', _type: 'metric', _domain: '用户', _level: 1, _category: 'core_metric', _weight: 0.9, _description: '日活跃用户数' },
        { id: '访购率', _type: 'metric', _domain: '转化', _level: 1, _category: 'core_metric', _weight: 0.9, _description: '访问用户到购买的转化率' },
        { id: '下单频次', _type: 'metric', _domain: '行为', _level: 1, _category: 'core_metric', _weight: 0.8, _description: '用户平均下单次数' },
        { id: '笔单价', _type: 'metric', _domain: '收益', _level: 1, _category: 'core_metric', _weight: 0.8, _description: '平均订单金额' },
        { id: '闪购DAU', _type: 'metric', _domain: '闪购', _level: 2, _category: 'segment', _weight: 0.7 },
        { id: '非闪购DAU', _type: 'metric', _domain: '非闪购', _level: 2, _category: 'segment', _weight: 0.6 },
        { id: 'ET端DAU', _type: 'metric', _domain: '闪购', _level: 3, _category: 'platform', _weight: 0.6 },
        { id: '营销补贴', _type: 'factor', _domain: '营销', _level: 2, _category: 'conversion_factor', _weight: 0.7, _description: '影响访购率的营销因素' },
        { id: '供给丰富度', _type: 'factor', _domain: '供给', _level: 2, _category: 'conversion_factor', _weight: 0.8, _description: '商户和商品供给情况' }
      ];
      const defaultEdges = [
        { from: 'DAU', to: '有效订单量', _type: 'rollup', _impact: 0.25 },
        { from: '访购率', to: '有效订单量', _type: 'rollup', _impact: 0.25 },
        { from: '下单频次', to: '有效订单量', _type: 'rollup', _impact: 0.25 },
        { from: '笔单价', to: '有效订单量', _type: 'rollup', _impact: 0.25 },
        { from: '闪购DAU', to: 'DAU', _type: 'rollup', _impact: 0.6 },
        { from: '非闪购DAU', to: 'DAU', _type: 'rollup', _impact: 0.4 },
        { from: 'ET端DAU', to: '闪购DAU', _type: 'rollup', _impact: 0.6 },
        { from: '营销补贴', to: '访购率', _type: 'influences', _impact: 0.4 },
        { from: '供给丰富度', to: '访购率', _type: 'influences', _impact: 0.35 }
      ];

      const idOf = G6.idOf;

      const transformData = (data) => {
        (data.edges || []).forEach((e) => { e.source = e.from; e.target = e.to; });
        return data;
      };

      const colorByCategory = (node) => {
        if (node._category === 'business_target') return CORE_TARGET;
        if (node._category === 'core_metric') return CORE_METRIC;
        if (node._category === 'segment' || node._category === 'platform' || node._category === 'user_group') return SEGMENT;
        if (node._category === 'conversion_factor' || node._category === 'supply_metric' || node._category === 'logistics_metric') return FACTOR;
        if (node._category === 'marketing_tool' || node._type === 'tool') return TOOL;
        if (node._type === 'factor') return FACTOR;
        return CORE_METRIC; // 默认颜色
      };

      const sizeBy = (nodeId, nodes, edges, minSize = 20, maxSize = 90) => {
        const node = nodes.find((n) => n.id === nodeId) || {};
        const degree = edges.filter((e) => e.source === nodeId || e.target === nodeId).length;
        const weight = Number(node._weight || 0);
        // 影响力 = 0.7*度数标准化 + 0.3*权重
        const degrees = nodes.map((n) => edges.filter((e) => e.source === n.id || e.target === n.id).length);
        const minD = Math.min(...degrees, 0);
        const maxD = Math.max(...degrees, 1);
        const normD = (degree - minD) / (maxD - minD || 1);
        const influence = 0.7 * normD + 0.3 * Math.min(weight, 1);
        return minSize + influence * (maxSize - minSize);
      };

      class OrganicLayout extends G6.BaseLayout {
        async execute(data) {
          const { gap = 60, ranksep = 120, nodeSize = 40, verticalSpread = 0.4, randomOffset = 0.15 } = this.options;
          const nodes = data.nodes.map(node => ({
            id: node.id,
            style: { ...node.style },
            _level: node._level || 0,
            _weight: node._weight || 0.5,
            _category: node._category,
            size: this.options.nodeSize ? this.options.nodeSize(node) : nodeSize
          }));

          // 按层级分组
          const layersObject = {};
          nodes.forEach(node => {
            const level = node._level;
            if (!(level in layersObject)) layersObject[level] = [];
            layersObject[level].push(node);
          });

          // 处理孤立节点
          const connectedNodes = new Set();
          data.edges.forEach(edge => {
            connectedNodes.add(edge.source);
            connectedNodes.add(edge.target);
          });

          const isolatedNodes = nodes.filter(n => !connectedNodes.has(n.id));
          if (isolatedNodes.length > 0) {
            const maxLevel = Math.max(...Object.keys(layersObject).map(Number));
            const isolatedLevel = maxLevel + 1;
            layersObject[isolatedLevel] = isolatedNodes.map(node => {
              node._level = isolatedLevel;
              return node;
            });
          }

          const sortedLevels = Object.keys(layersObject).map(Number).sort((a, b) => a - b);
          
          // 为每层计算位置
          sortedLevels.forEach(level => {
            const layer = layersObject[level];
            const layerSize = layer.length;
            
            // 如果是第一层（L0），按重要性排序
            if (level === 0) {
              layer.sort((a, b) => {
                const degreeA = data.edges.filter(e => e.source === a.id || e.target === a.id).length;
                const degreeB = data.edges.filter(e => e.source === b.id || e.target === b.id).length;
                const importanceA = (a._weight || 0) * 0.3 + degreeA * 0.7;
                const importanceB = (b._weight || 0) * 0.3 + degreeB * 0.7;
                return importanceB - importanceA;
              });
            } else {
              // 对于其他层级，根据与前一层的连接关系进行分组排序
              const prevLevel = level - 1;
              const prevLayer = layersObject[prevLevel] || [];
              
              // 创建连接组
              const connectionGroups = [];
              const unconnectedNodes = [];
              
              // 为前一层的每个节点创建对应的连接组
              prevLayer.forEach((prevNode, prevIndex) => {
                const connectedNodes = [];
                
                // 找到连接到这个前一层节点的当前层节点
                data.edges.forEach(edge => {
                  if (edge.source === prevNode.id) {
                    const targetNode = layer.find(n => n.id === edge.target);
                    if (targetNode) connectedNodes.push(targetNode);
                  }
                  if (edge.target === prevNode.id) {
                    const sourceNode = layer.find(n => n.id === edge.source);
                    if (sourceNode) connectedNodes.push(sourceNode);
                  }
                });
                
                if (connectedNodes.length > 0) {
                  // 按重要性对组内节点排序
                  connectedNodes.sort((a, b) => {
                    const degreeA = data.edges.filter(e => e.source === a.id || e.target === a.id).length;
                    const degreeB = data.edges.filter(e => e.source === b.id || e.target === b.id).length;
                    const importanceA = (a._weight || 0) * 0.3 + degreeA * 0.7;
                    const importanceB = (b._weight || 0) * 0.3 + degreeB * 0.7;
                    return importanceB - importanceA;
                  });
                  
                  connectionGroups.push({
                    prevNode: prevNode,
                    prevIndex: prevIndex,
                    nodes: connectedNodes,
                    targetY: prevNode.style.y || 0
                  });
                }
              });
              
              // 找出未连接的节点
              const connectedNodeIds = new Set();
              connectionGroups.forEach(group => {
                group.nodes.forEach(node => connectedNodeIds.add(node.id));
              });
              
              layer.forEach(node => {
                if (!connectedNodeIds.has(node.id)) {
                  unconnectedNodes.push(node);
                }
              });
              
              // 按前一层节点的Y位置排序连接组
              connectionGroups.sort((a, b) => a.targetY - b.targetY);
              
              // 重新组装layer数组，保持连接关系的垂直对应
              const sortedLayer = [];
              connectionGroups.forEach(group => {
                sortedLayer.push(...group.nodes);
              });
              
              // 将未连接的节点按重要性排序后添加到末尾
              unconnectedNodes.sort((a, b) => {
                const degreeA = data.edges.filter(e => e.source === a.id || e.target === a.id).length;
                const degreeB = data.edges.filter(e => e.source === b.id || e.target === b.id).length;
                const importanceA = (a._weight || 0) * 0.3 + degreeA * 0.7;
                const importanceB = (b._weight || 0) * 0.3 + degreeB * 0.7;
                return importanceB - importanceA;
              });
              sortedLayer.push(...unconnectedNodes);
              
              // 更新layer为排序后的数组
              layersObject[level] = sortedLayer;
              layer.length = 0;
              layer.push(...sortedLayer);
            }

            // 计算X坐标（层级位置）
            const baseX = level * ranksep;
            
            // 计算节点间的最小间距（考虑节点大小）
            const getMinSpacing = (nodeA, nodeB) => {
              const sizeA = nodeA.size || nodeSize;
              const sizeB = nodeB.size || nodeSize;
              return (sizeA + sizeB) / 2 + gap;
            };
            
            // 计算Y坐标（垂直分布）
            if (layerSize === 1) {
              layer[0].style.x = baseX + (Math.random() - 0.5) * randomOffset * ranksep * 0.3;
              layer[0].style.y = (Math.random() - 0.5) * randomOffset * gap * 0.3;
            } else {
              // 计算总需要的高度
              let totalHeight = 0;
              for (let i = 0; i < layerSize - 1; i++) {
                totalHeight += getMinSpacing(layer[i], layer[i + 1]);
              }
              
              // 分配Y坐标
              let currentY = -totalHeight / 2;
              layer.forEach((node, index) => {
                if (index === 0) {
                  node.style.y = currentY;
                } else {
                  currentY += getMinSpacing(layer[index - 1], node);
                  node.style.y = currentY;
                }
                
                // 添加垂直交错（减少幅度）
                const stagger = (index % 2 === 0 ? 1 : -1) * verticalSpread * gap * 0.2;
                
                // 添加微量随机偏移
                const randomY = (Math.random() - 0.5) * randomOffset * gap * 0.5;
                const randomX = (Math.random() - 0.5) * randomOffset * ranksep * 0.2;
                
                // 重要节点位置微调（更靠近中心）
                const importance = (node._weight || 0) + 
                  data.edges.filter(e => e.source === node.id || e.target === node.id).length * 0.1;
                const importanceY = -importance * gap * 0.1;
                
                node.style.x = baseX + randomX;
                node.style.y = node.style.y + stagger + randomY + importanceY;
              });
            }
          });

          // 碰撞检测和调整
          this.resolveCollisions(nodes, gap * 0.8);

          return { nodes };
        }

        // 碰撞检测和解决方法
        resolveCollisions(nodes, minDistance) {
          const maxIterations = 10;
          let iteration = 0;
          
          while (iteration < maxIterations) {
            let hasCollision = false;
            
            for (let i = 0; i < nodes.length; i++) {
              for (let j = i + 1; j < nodes.length; j++) {
                const nodeA = nodes[i];
                const nodeB = nodes[j];
                
                // 只检查相邻层级的节点
                if (Math.abs(nodeA._level - nodeB._level) > 1) continue;
                
                const dx = nodeA.style.x - nodeB.style.x;
                const dy = nodeA.style.y - nodeB.style.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const sizeA = nodeA.size || 40;
                const sizeB = nodeB.size || 40;
                const requiredDistance = (sizeA + sizeB) / 2 + minDistance;
                
                if (distance < requiredDistance && distance > 0) {
                  hasCollision = true;
                  
                  // 计算调整向量
                  const overlap = requiredDistance - distance;
                  const adjustX = (dx / distance) * overlap * 0.5;
                  const adjustY = (dy / distance) * overlap * 0.5;
                  
                  // 同层级的节点主要在Y方向调整，不同层级的在X方向也调整
                  if (nodeA._level === nodeB._level) {
                    nodeA.style.y += adjustY;
                    nodeB.style.y -= adjustY;
                  } else {
                    nodeA.style.x += adjustX * 0.3;
                    nodeA.style.y += adjustY;
                    nodeB.style.x -= adjustX * 0.3;
                    nodeB.style.y -= adjustY;
                  }
                }
              }
            }
            
            if (!hasCollision) break;
            iteration++;
          }
        }
      }

      class ClickElement extends G6.BaseBehavior {
        constructor(context, options) { super(context, options); this.bindEvents(); }
        async clearState() { const { graph } = this.context; const { nodes, edges } = graph.getData(); const s = {}; [...nodes, ...edges].forEach(d => s[idOf(d)] = []); await graph.setElementState(s, false); }
        onNodeClick = async (event) => {
          await this.clearState();
          toggleListVisibility(false);
          const { direction = 'out', onlyNeighbors } = event;
          const nodeId = event.target.id; const { graph } = this.context; const { nodes, edges } = graph.getData();
          let relatedIds;
          if (onlyNeighbors) {
            const neighborNodes = graph.getNeighborNodesData(nodeId);
            const neighborEdges = graph.getRelatedEdgesData(nodeId);
            const oneLevelIds = [...neighborNodes, ...neighborEdges].map(idOf);
            relatedIds = [...oneLevelIds, nodeId];
            graph.updateNodeData(prev => prev.filter(n => relatedIds.includes(n.id) && (n.style.level = oneLevelIds.includes(n.id) ? 1 : 0)));
            const states = {}; [...nodes, ...edges].forEach(d => states[idOf(d)] = relatedIds.includes(idOf(d)) ? ['link'] : ['inactive']);
            await graph.setElementState(states);
          } else {
            const levels = getLevelMap(nodeId, direction);
            relatedIds = Object.keys(levels);
            graph.updateNodeData(prev => prev.filter(n => relatedIds.includes(n.id) && (n.style.level = levels[n.id])));
            graph.updateEdgeData(prev => prev.filter(e => (levels[e.source] || levels[e.target]) && (e.style.level = Math.min(levels[e.source], levels[e.target]))));
            const states = {}; nodes.forEach(n => states[n.id] = relatedIds.includes(n.id) ? ['link'] : ['inactive']);
            edges.forEach(e => states[idOf(e)] = relatedIds.includes(e.source) && relatedIds.includes(e.target) ? ['link'] : ['inactive']);
            await graph.setElementState(states);
          }
        };
        onCanvasClick = async () => { await this.clearState(); toggleListVisibility(false); clearSearchInput(); };
        bindEvents() { const { graph } = this.context; graph.on('node:click', this.onNodeClick); graph.on('canvas:click', this.onCanvasClick); }
        unbindEvents() { const { graph } = this.context; graph.off('node:click', this.onNodeClick); graph.off('canvas:click', this.onCanvasClick); }
        destroy() { this.unbindEvents(); super.destroy(); }
      }

      const getLevelMap = (nodeId, direction) => {
        const stack = [nodeId]; const visited = new Set(); const levelMap = { [nodeId]: 0 };
        const processEdge = (source, target, parentLevel) => { if (!visited.has(target)) { const nl = parentLevel + 1; if (!levelMap[target] || nl < levelMap[target]) { levelMap[target] = nl; stack.push(target); } } };
        while (stack.length) { const id = stack.pop(); if (!visited.has(id)) { visited.add(id); const pl = levelMap[id]; const related = graph.getRelatedEdgesData(id); related.forEach(edge => {
          if (direction === 'out') { if (edge.source === id) processEdge(edge.source, edge.target, pl); else if (edge._bidirectional) processEdge(edge.target, edge.source, pl); }
          else if (direction === 'in') { if (edge.target === id) processEdge(edge.target, edge.source, pl); else if (edge._bidirectional) processEdge(edge.source, edge.target, pl); }
        }); } }
        return levelMap;
      };

      const toggleListVisibility = (isShow) => { document.getElementById('search-list').style.display = isShow ? 'block' : 'none'; };
      const clearSearchInput = () => { document.getElementById('searchInput').value = ''; };
      const removeElement = (el) => { while (el.firstChild) el.removeChild(el.firstChild); };

      class SearchBar extends G6.BasePlugin {
        liveAlert = document.getElementById('live-alert');
        searchInput = document.getElementById('searchInput');
        searchButton = document.getElementById('searchButton');
        target;
        constructor(context, options) { super(context, options); this.bindEvents(); }
        appendAlert = (message, type) => { removeElement(this.liveAlert); const w = document.createElement('div'); w.innerHTML = [`<div class="alert alert-${type} alert-dismissible alert-message" role="alert">`, `   <div>${message}</div>`, '   <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>', '</div>'].join(''); this.liveAlert.append(w); };
        handleInputKeyup = (event) => {
          const { graph } = this.context; removeElement(this.liveAlert);
          const PRE = '<b style="color: #1783FF;">'; const POST = '</b>';
          const data = graph.getData(); const nodeList = data.nodes.map(n => ({ id: n.id }));
          const filtered = fuzzy.filter(this.searchInput.value, nodeList, { pre: PRE, post: POST, extract: el => el.id });
          const sorted = filtered.sort((a, b) => { const regx = new RegExp(PRE, 'g'); const ac = (a.string.match(regx) || []).length; const bc = (b.string.match(regx) || []).length; if (ac !== bc) return bc - ac; const regx2 = new RegExp(POST + PRE, 'g'); const as = (a.string.match(regx2) || []).length; const bs = (b.string.match(regx2) || []).length; if (as !== bs) return bs - as; return a.string.indexOf(PRE) - b.string.indexOf(PRE); });
          document.getElementById('search-list').innerHTML = sorted.map(el => `<div class="mb-1">${el.string}</div>`).join('');
          this.target = sorted[0]?.original.id || '';
          toggleListVisibility(true);
          if (event.keyCode === 13) { event.preventDefault(); this.searchButton.click(); }
          else if (this.searchInput.value === '') { graph.emit('canvas:click', { targetType: 'canvas' }); }
        };
        handleButtonClick = async () => { const { graph } = this.context; const v = this.searchInput.value; if (!v) return; if (!this.target) { this.appendAlert(`未找到 “${v}”`, 'warning'); graph.emit('canvas:click', { targetType: 'canvas' }); }
          graph.emit('node:click', { target: graph.getNodeData(this.target), targetType: 'node', direction: 'out' }); await graph.fitView(); };
        bindEvents() { this.searchInput.addEventListener('keyup', this.handleInputKeyup); this.searchButton.addEventListener('click', this.handleButtonClick); }
        unbindEvents() { this.searchInput.removeEventListener('keyup', this.handleInputKeyup); this.searchButton.removeEventListener('click', this.handleButtonClick); }
        destroy() { this.unbindEvents(); super.destroy(); }
      }

      class DetailContent extends G6.BasePlugin {
        nodeDetail = document.getElementById('node-detail');
        constructor(context, options) { super(context, options); this.bindEvents(); }
        appendDetail = (node) => {
          removeElement(this.nodeDetail);
          if (!node) return;
          const line = (k, v) => { const div = document.createElement('div'); div.className = 'metric-line'; div.innerHTML = `<span class="k">${k}</span><span class="v">${v}</span>`; return div; };
          const title = document.createElement('div'); title.style.fontWeight = '700'; title.style.marginBottom = '4px'; title.innerText = node.id; this.nodeDetail.appendChild(title);
          if (node._description) this.nodeDetail.appendChild(line('说明', node._description));
          if (node._domain) this.nodeDetail.appendChild(line('业务域', node._domain));
          if (node._category) this.nodeDetail.appendChild(line('类型', node._category));
          if (node._level != null) this.nodeDetail.appendChild(line('层级', `L${node._level}`));
          if (node._weight != null) this.nodeDetail.appendChild(line('权重', node._weight));
        };
        onNodeClick = (event) => { const { target } = event; const { graph } = this.context; const data = graph.getNodeData(target.id); this.appendDetail(data); };
        onCanvasClick = () => { removeElement(this.nodeDetail); };
        bindEvents() { const { graph } = this.context; graph.on('node:click', this.onNodeClick); graph.on('canvas:click', this.onCanvasClick); }
        unbindEvents() { const { graph } = this.context; graph.off('node:click', this.onNodeClick); graph.off('canvas:click', this.onCanvasClick); }
        destroy() { this.unbindEvents(); super.destroy(); }
      }

      G6.register('behavior', 'click-element', ClickElement);
      G6.register('layout', 'organic', OrganicLayout);

      const toolbarOption = { type: 'toolbar', position: 'bottom-left', onClick: (item) => { if (item === 'zoom-in') graph.zoomBy(1.2); if (item === 'zoom-out') graph.zoomBy(0.8); if (item === 'auto-fit') graph.fitView(); }, getItems: () => ([{ id: 'zoom-in', value: 'zoom-in' }, { id: 'zoom-out', value: 'zoom-out' }, { id: 'auto-fit', value: 'auto-fit' }]) };

      const contextmenuOption = { type: 'contextmenu', trigger: 'contextmenu', onClick: (v, element, target) => { if (v === 'reference-network') graph.emit('node:click', { target, targetType: 'node', direction: 'out' }); if (v === 'citation-network') graph.emit('node:click', { target, targetType: 'node', direction: 'in' }); if (v === 'direct-neighbors') graph.emit('node:click', { target, targetType: 'node', onlyNeighbors: true }); graph.fitView(); }, getItems: () => ([{ name: '下游影响网络', value: 'reference-network' }, { name: '上游依赖网络', value: 'citation-network' }, { name: '直接邻居', value: 'direct-neighbors' }]), enable: (e) => e.targetType === 'node' };

      const colorOfEdge = (e) => {
        if (e._type === 'rollup') return '#6366f1'; // 紫色，表示聚合关系
        if (e._type === 'influences') return '#0891b2'; // 蓝色，表示影响关系
        if (e._type === 'depends') return '#dc2626'; // 红色，表示依赖关系
        return '#94a3b8'; // 默认灰色
      };
      const lineDashOf = (e) => {
        if (e._type === 'influences') return [6, 6]; // 影响关系用虚线
        if (e._type === 'depends') return [3, 3]; // 依赖关系用短虚线
        return undefined; // rollup用实线
      };

      // 先注册插件
      G6.register('plugin', 'search-bar', SearchBar);
      G6.register('plugin', 'detail-content', DetailContent);

      // 提升为全局，便于行为/函数访问
      let graph;

      const buildGraph = async (graphData) => {
        console.log('构建图谱，输入数据:', graphData);
        const data = transformData(graphData);
        console.log('转换后数据:', data);
        graph = new G6.Graph({
          container: 'network',
          data: data,
          animation: false,
          autoFit: 'view',
          padding: [0, 20, 0, 60],
          background: BG_COLOR,
          node: {
            style: {
              size: (d) => sizeBy(d.id, data.nodes, data.edges),
              fill: (d) => colorByCategory(d),
              iconFontFamily: 'iconfont',
              iconText: (d) => {
                if (d._category === 'business_target') return '\uE65F'; // 目标
                if (d._category === 'core_metric') return '\uE7B0'; // 指标
                if (d._category === 'segment' || d._category === 'platform') return '\uE6AB'; // 平台
                if (d._category === 'user_group' || d._category === 'user_type') return '\uE65D'; // 用户
                if (d._category === 'conversion_factor' || d._type === 'factor') return '\uE6CA'; // 因子
                if (d._category === 'marketing_tool' || d._type === 'tool') return '\uE6BB'; // 工具
                return '\uE7B0';
              },
              label: true,
              labelText: (d) => d._description ? `${d.id}\n${d._description}` : d.id,
              labelFontSize: 11,
              labelBackground: true,
              labelBackgroundFill: '#e5e7eb',
              labelPadding: [0, 6],
              labelBackgroundRadius: 4,
              labelMaxWidth: '300%',
              labelWordWrap: true
            },
            state: {
              inactive: { fill: '#cbd5e1', iconOpacity: 0.6, labelBackground: false },
              link: { labelFontWeight: 'bold', halo: (d) => d.style.level === 0 }
            }
          },
          edge: {
            style: {
              stroke: (e) => colorOfEdge(e),
              lineDash: (e) => lineDashOf(e),
              endArrow: true,
              lineWidth: (e) => 1 + 2 * Number(e._impact || 0),
              type: (e) => {
                // 根据关系类型选择不同的连线样式
                if (e._type === 'influences') return 'quadratic'; // 影响关系用曲线
                if (e._type === 'depends') return 'cubic'; // 依赖关系用贝塞尔曲线
                return 'polyline'; // rollup用折线（更有机）
              },
              controlPoints: (e) => {
                // 为不同类型的边添加控制点，增加有机感
                if (e._type === 'influences') {
                  return [{ x: 0.3, y: 0.2 }, { x: 0.7, y: -0.2 }]; // 轻微波浪
                }
                if (e._type === 'depends') {
                  return [{ x: 0.25, y: -0.3 }, { x: 0.75, y: 0.3 }]; // S形曲线
                }
                return undefined; // rollup保持直线或轻微弯曲
              },
              opacity: 0.8,
              strokeOpacity: 0.8
            },
            state: {
              inactive: { opacity: 0.15, strokeOpacity: 0.15 },
              link: { 
                lineWidth: (e) => 1.5 + 2 * Number(e._impact || 0), 
                halo: false,
                opacity: 1,
                strokeOpacity: 1
              }
            }
          },
          layout: [
            { type: 'antv-dagre', rankdir: 'LR', ranksep: 140, nodesep: 30, controlPoints: true, nodeSize: (d) => sizeBy(d.id, data.nodes, data.edges) + 20 },
            { type: 'organic', gap: 80, ranksep: 140, verticalSpread: 0.3, randomOffset: 0.1, nodeSize: (d) => sizeBy(d.id, data.nodes, data.edges) }
          ],
          behaviors: ['drag-element', 'drag-canvas', 'zoom-canvas', 'click-element'],
          plugins: [toolbarOption, contextmenuOption, 'search-bar', 'detail-content']
        });

        await document.fonts.ready;
        await graph.render();
        setTimeout(() => {
          graph.render();
          document.getElementById('loading-status').style.display = 'none';
        }, 16);
        return graph;
      };

      const fetchJsonSafe = async (path) => {
        try {
          const res = await fetch(path, { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          return await res.json();
        } catch (e) { return null; }
      };

      let lastKnownModified = null;
      let refreshInterval = null;

      const loadAndRenderGraph = async () => {
        // 优先尝试从Markdown解析API加载数据
        let graphData = await fetchJsonSafe('http://localhost:3001/api/graph-data');
        
        // 如果API不可用，尝试静态JSON文件
        if (!graphData) {
          console.log('Markdown API不可用，尝试静态JSON文件');
          const loadedNodes = await fetchJsonSafe('./data/nodes.json');
          const loadedEdges = await fetchJsonSafe('./data/edges.json');
          graphData = {
            nodes: loadedNodes || defaultNodes,
            edges: loadedEdges || defaultEdges
          };
        } else {
          console.log('成功从Markdown解析API加载数据');
          console.log('节点数:', graphData.nodes?.length, '边数:', graphData.edges?.length);
        }

        // 如果已有图实例，销毁后重建
        if (graph) {
          graph.destroy();
        }
        graph = await buildGraph(graphData);
      };

      const checkForUpdates = async () => {
        try {
          const status = await fetchJsonSafe('http://localhost:3001/api/status');
          if (status && status.lastModified && status.lastModified !== lastKnownModified) {
            console.log('检测到datas.md文件变化，重新加载图谱');
            lastKnownModified = status.lastModified;
            await loadAndRenderGraph();
          }
        } catch (error) {
          console.log('无法检查文件状态，API可能不可用');
        }
      };

      const main = async () => {
        await loadAndRenderGraph();
        
        // 启动定期检查文件变化
        refreshInterval = setInterval(checkForUpdates, 2000);
        
        // 获取初始文件状态
        try {
          const status = await fetchJsonSafe('http://localhost:3001/api/status');
          if (status && status.lastModified) {
            lastKnownModified = status.lastModified;
          }
        } catch (error) {
          console.log('无法获取初始文件状态');
        }
      };

      main();
    </script>
  </body>
</html>


